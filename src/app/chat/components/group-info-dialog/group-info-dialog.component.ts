import { Component, OnInit, Input, Output, EventEmitter, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import { GroupsService } from '../../../api/services/groups.service';
import { ToastService } from '../../../shared/services/toast.service';
import { CommonInputComponent } from '../../../shared/components/common-form-controls/common-input.component';
import { CommonButtonComponent } from '../../../shared/components/common-form-controls/common-button.component';
import { SkeletonLoaderComponent } from '../../../shared/components/skeleton-loader/skeleton-loader.component';
import { ConfirmationDialogComponent } from '../../../shared/components/confirmation-dialog/confirmation-dialog.component';
import { TabsComponent, Tab } from '../../../shared/components/tabs/tabs.component';
import { CompactMemberListComponent } from '../compact-member-list/compact-member-list.component';
import { GroupDto } from '../../../api/models/group-dto';
import { GroupMemberDto } from '../../../api/models/group-member-dto';
import { CommonTooltipDirective } from '../../../shared/components/common-tooltip';
import { TranslatePipe, I18nService } from '../../../core/i18n';

/**
 * Production-ready Group Info Dialog Component with MNC coding standards
 *
 * Features:
 * - Tabbed interface (General, Members, Settings)
 * - Member management with admin controls
 * - API integration using autogenerated models
 * - Accessible markup with ARIA attributes
 * - OnPush change detection for performance
 * - Permission-based UI controls
 * - Skeleton loading states
 *
 * @example
 * ```typescript
 * <app-group-info-dialog
 *   [groupId]="selectedGroupId"
 *   [currentUserId]="currentUserId"
 *   (closed)="onDialogClose()"
 *   (groupUpdated)="onGroupUpdated()"
 *   (groupDeleted)="onGroupDeleted($event)">
 * </app-group-info-dialog>
 * ```
 */
@Component({
  selector: 'app-group-info-dialog',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    CommonInputComponent,
    CommonButtonComponent,
    SkeletonLoaderComponent,
    ConfirmationDialogComponent,
    TabsComponent,
    CompactMemberListComponent,
    CommonTooltipDirective,
    TranslatePipe
  ],
  templateUrl: './group-info-dialog.component.html',
  styleUrls: ['./group-info-dialog.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class GroupInfoDialogComponent implements OnInit {
  @Input() groupId!: string;
  @Input() currentUserId!: string;
  @Input() triggerDelete = false; // Auto-trigger delete confirmation when true
  @Output() closed = new EventEmitter<void>();
  @Output() updated = new EventEmitter<GroupDto>();
  @Output() deleted = new EventEmitter<string>();
  @Output() leftGroup = new EventEmitter<string>();
  @Output() membershipChange = new EventEmitter<{ userId: string; action: 'remove' | 'makeAdmin' }>();

  // Tabs configuration - will be updated with translations
  tabs: Tab[] = [];
  activeTab: string = 'general';

  // Data
  group: GroupDto | null = null;
  members: GroupMemberDto[] = [];
  groupInfoForm!: FormGroup;

  // Loading states
  isLoadingGroup = true;
  isLoadingMembers = false;
  isUpdating = false;
  isDeleting = false;
  isLeaving = false;
  isUpdatingVisibility = false;
  processingUserId: string | null = null;

  // Confirmation dialogs
  showDeleteConfirmation = false;
  showLeaveConfirmation = false;
  showVisibilityConfirmation = false;
  showRemoveMemberConfirmation = false;
  memberToRemove: GroupMemberDto | null = null;
  pendingVisibilityValue: boolean | null = null;

  constructor(
    private fb: FormBuilder,
    private groupsService: GroupsService,
    private toastService: ToastService,
    private router: Router,
    private cdr: ChangeDetectorRef,
    private i18n: I18nService
  ) {
    this.updateTabs();
  }

  private updateTabs(): void {
    this.tabs = [
      { id: 'general', label: this.i18n.t('dialogs.group-information.navigation.general'), icon: 'bi-info-circle' },
      { id: 'members', label: this.i18n.t('dialogs.group-information.navigation.members'), icon: 'bi-people' },
      { id: 'settings', label: this.i18n.t('dialogs.group-information.navigation.settings'), icon: 'bi-gear' }
    ];
  }

  ngOnInit(): void {
    this.groupInfoForm = this.fb.group({
      groupName: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(50)]]
    });

    this.loadGroupDetails();

    // Auto-trigger delete confirmation if requested
    if (this.triggerDelete) {
      setTimeout(() => {
        this.showDeleteDialog();
      }, 100);
    }
  }

  /**
   * Load group details from API
   */
  private loadGroupDetails(): void {
    this.isLoadingGroup = true;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdGet$Json({ id: this.groupId }).subscribe({
      next: (response) => {
        this.isLoadingGroup = false;
        if (response.success && response.data) {
          this.group = response.data;
          this.groupInfoForm.patchValue({
            groupName: this.group.name || ''
          });
          this.cdr.markForCheck();
        } else {
          this.toastService.showError('Failed to load group details', 'Error');
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isLoadingGroup = false;
        const errorMessage = error?.error?.message || error?.message || 'Failed to load group details';
        this.toastService.showError(errorMessage, 'Error');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Load group members from API
   */
  private loadMembers(): void {
    this.isLoadingMembers = true;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdMembersGet$Json({ id: this.groupId }).subscribe({
      next: (response) => {
        this.isLoadingMembers = false;
        if (response.success && response.data) {
          this.members = response.data;
          this.cdr.markForCheck();
        } else {
          this.toastService.showError('Failed to load members', 'Error');
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isLoadingMembers = false;
        const errorMessage = error?.error?.message || error?.message || 'Failed to load members';
        this.toastService.showError(errorMessage, 'Error');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Handle tab change
   */
  onTabChange(tabId: string): void {
    this.activeTab = tabId;

    // Load members when switching to Members tab
    if ((tabId === 'members' || tabId === 'settings') && this.members.length === 0) {
      this.loadMembers();
    }

    this.cdr.markForCheck();
  }

  /**
   * Check if current user is admin
   */
  get isAdmin(): boolean {
    if (!this.members || !this.currentUserId) {
      return false;
    }
    return this.members.some(m => m.userId === this.currentUserId && m.role === 'admin');
  }

  /**
   * Check if current user is the last admin
   */
  get isLastAdmin(): boolean {
    if (!this.members || !this.currentUserId || !this.isAdmin) {
      return false;
    }
    const adminCount = this.members.filter(m => m.role === 'admin').length;
    return adminCount === 1;
  }

  getFieldError(fieldName: string): boolean {
    const field = this.groupInfoForm.get(fieldName);
    return !!(field && field.invalid && (field.dirty || field.touched));
  }

  getErrorMessage(fieldName: string): string {
    const field = this.groupInfoForm.get(fieldName);
    if (!field || !field.errors) {
      return '';
    }

    if (field.errors['required']) {
      return 'Group name is required';
    }
    if (field.errors['minlength']) {
      return 'Group name must be at least 3 characters';
    }
    if (field.errors['maxlength']) {
      return 'Group name must not exceed 50 characters';
    }
    return '';
  }

  /**
   * Submit group updates
   */
  onSubmit(): void {
    if (this.groupInfoForm.invalid || this.isUpdating) {
      return;
    }

    this.isUpdating = true;
    this.cdr.markForCheck();

    const formValue = this.groupInfoForm.value;
    const groupName = formValue.groupName.trim();

    // Update group name
    this.groupsService.apiGroupsIdNamePut$Json({
      id: this.groupId,
      body: {
        name: groupName
      }
    }).subscribe({
      next: (response) => {
        this.isUpdating = false;
        if (response.success) {
          this.toastService.showSuccess('Group information updated.', 'Success');
          if (this.group) {
            this.group.name = groupName;
          }
          this.updated.emit(this.group!);
          this.groupInfoForm.markAsPristine();
          this.cdr.markForCheck();
        } else {
          this.toastService.showError(response.message || 'Failed to update group', 'Error');
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isUpdating = false;
        const errorMessage = error?.error?.message || error?.message || 'Failed to update group. Please try again.';
        this.toastService.showError(errorMessage, 'Error');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Make a member an admin
   */
  onMakeAdmin(userId: string): void {
    if (!this.isAdmin || this.processingUserId) {
      return;
    }

    this.processingUserId = userId;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdMembersUserIdMakeAdminPost$Json({
      id: this.groupId,
      userId: userId
    }).subscribe({
      next: (response) => {
        this.processingUserId = null;
        if (response.success) {
          this.toastService.showSuccess('Member promoted to admin', 'Success');
          // Update local member role
          const member = this.members.find(m => m.userId === userId);
          if (member) {
            member.role = 'admin';
          }
          this.membershipChange.emit({ userId, action: 'makeAdmin' });
          this.cdr.markForCheck();
        } else {
          this.toastService.showError(response.message || 'Failed to make admin', 'Error');
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.processingUserId = null;
        const errorMessage = error?.error?.message || error?.message || 'Failed to make admin';
        this.toastService.showError(errorMessage, 'Error');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Show remove member confirmation
   */
  onRemoveMember(userId: string): void {
    const member = this.members.find(m => m.userId === userId);
    if (member) {
      this.memberToRemove = member;
      this.showRemoveMemberConfirmation = true;
      this.cdr.markForCheck();
    }
  }

  /**
   * Confirm remove member
   */
  confirmRemoveMember(): void {
    if (!this.memberToRemove || this.processingUserId) {
      return;
    }

    const userId = this.memberToRemove.userId;
    if (!userId) {
      return;
    }

    this.processingUserId = userId;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdMembersUserIdDelete$Json({
      id: this.groupId,
      userId: userId
    }).subscribe({
      next: (response) => {
        this.processingUserId = null;
        this.showRemoveMemberConfirmation = false;
        this.memberToRemove = null;
        if (response.success) {
          this.toastService.showSuccess('Member removed from group', 'Success');
          // Remove from local array
          this.members = this.members.filter(m => m.userId !== userId);
          this.membershipChange.emit({ userId, action: 'remove' });
          this.cdr.markForCheck();
        } else {
          this.toastService.showError(response.message || 'Failed to remove member', 'Error');
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.processingUserId = null;
        this.showRemoveMemberConfirmation = false;
        this.memberToRemove = null;
        const errorMessage = error?.error?.message || error?.message || 'Failed to remove member';
        this.toastService.showError(errorMessage, 'Error');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Cancel remove member
   */
  cancelRemoveMember(): void {
    this.showRemoveMemberConfirmation = false;
    this.memberToRemove = null;
    this.cdr.markForCheck();
  }

  /**
   * Handle member click (navigate to profile)
   */
  onMemberClick(userId: string): void {
    // TODO: Implement navigation to user profile or emit event
    console.log('Navigate to user profile:', userId);
  }

  /**
   * Tooltip for the Delete Group button
   */
  get deleteGroupTooltip(): string {
    if (this.isDeleting) {
      return 'Deleting group...';
    }
    if (!this.isAdmin) {
      return 'Only group admins can delete this group';
    }
    return 'Permanently delete this group';
  }

  /**
   * Tooltip for the Leave Group button
   */
  get leaveGroupTooltip(): string {
    if (this.isLeaving) {
      return 'Leaving group...';
    }
    if (this.isLastAdmin) {
      return 'You are the last admin. Please assign another admin before leaving or delete the group';
    }
    return 'Leave this group';
  }

  /**
   * Tooltip for the Change Visibility button
   */
  get changeVisibilityTooltip(): string {
    if (this.isUpdatingVisibility) {
      return 'Updating visibility...';
    }
    if (!this.isAdmin) {
      return 'Only group admins can change visibility';
    }
    const currentState = this.group?.isPublic ? 'public' : 'private';
    const newState = this.group?.isPublic ? 'private' : 'public';
    return `Change group visibility from ${currentState} to ${newState}`;
  }

  /**
   * Handle delete button click
   */
  onDeleteClick(): void {
    if (!this.isAdmin || this.isDeleting) {
      return;
    }
    this.showDeleteDialog();
  }

  /**
   * Handle leave group button click
   */
  onLeaveClick(): void {
    if (this.isLeaving || this.isLastAdmin) {
      return;
    }
    this.showLeaveDialog();
  }

  /**
   * Handle visibility toggle click
   */
  onVisibilityToggle(): void {
    if (!this.isAdmin || this.isUpdatingVisibility || !this.group) {
      return;
    }
    // Store the pending value (opposite of current)
    this.pendingVisibilityValue = !this.group.isPublic;
    this.showVisibilityDialog();
  }

  closeDialog(): void {
    this.closed.emit();
  }

  /**
   * Show delete confirmation dialog
   */
  showDeleteDialog(): void {
    this.showDeleteConfirmation = true;
    this.cdr.markForCheck();
  }

  /**
   * Cancel delete operation
   */
  cancelDelete(): void {
    this.showDeleteConfirmation = false;
    this.cdr.markForCheck();
  }

  /**
   * Show leave confirmation dialog
   */
  showLeaveDialog(): void {
    this.showLeaveConfirmation = true;
    this.cdr.markForCheck();
  }

  /**
   * Cancel leave operation
   */
  cancelLeave(): void {
    this.showLeaveConfirmation = false;
    this.cdr.markForCheck();
  }

  /**
   * Show visibility change confirmation dialog
   */
  showVisibilityDialog(): void {
    this.showVisibilityConfirmation = true;
    this.cdr.markForCheck();
  }

  /**
   * Cancel visibility change operation
   */
  cancelVisibilityChange(): void {
    this.showVisibilityConfirmation = false;
    this.pendingVisibilityValue = null;
    this.cdr.markForCheck();
  }

  /**
   * Confirm and execute group deletion
   */
  confirmDelete(): void {
    if (this.isDeleting || !this.groupId) {
      return;
    }

    this.isDeleting = true;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdDelete$Json({ id: this.groupId }).subscribe({
      next: (response) => {
        this.isDeleting = false;
        this.showDeleteConfirmation = false;

        if (response.success) {
          this.toastService.showSuccess(
            'Group and all associated data have been permanently deleted.',
            'Group Deleted'
          );

          this.deleted.emit(this.groupId);
          this.closeDialog();
          this.router.navigate(['/chat']);
        } else {
          this.toastService.showError(
            response.message || 'Failed to delete group',
            'Delete Failed'
          );
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isDeleting = false;
        this.showDeleteConfirmation = false;

        const errorMessage = error?.error?.message
          || error?.message
          || 'Failed to delete group. Please try again.';

        this.toastService.showError(errorMessage, 'Delete Failed');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Confirm and execute leave group
   */
  confirmLeave(): void {
    if (this.isLeaving || !this.groupId || this.isLastAdmin) {
      return;
    }

    this.isLeaving = true;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdLeavePost$Json({ id: this.groupId }).subscribe({
      next: (response) => {
        this.isLeaving = false;
        this.showLeaveConfirmation = false;

        if (response.success) {
          this.toastService.showSuccess(
            'You have successfully left the group.',
            'Left Group'
          );

          this.leftGroup.emit(this.groupId);
          this.closeDialog();
          this.router.navigate(['/chat']);
        } else {
          this.toastService.showError(
            response.message || 'Failed to leave group',
            'Leave Failed'
          );
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isLeaving = false;
        this.showLeaveConfirmation = false;

        const errorMessage = error?.error?.message
          || error?.message
          || 'Failed to leave group. Please try again.';

        this.toastService.showError(errorMessage, 'Leave Failed');
        this.cdr.markForCheck();
      }
    });
  }

  /**
   * Formats a given date-time string into a professional tooltip with:
   * - Day of the week (e.g., "Monday")
   * - Day of the month (e.g., 29)
   * - Full month name (e.g., "October")
   * - Full year (e.g., 2025)
   * - Time in 12-hour format with AM/PM in a concise style (e.g., "6:46 PM")
   *
   * @param {string} [timeString] - The ISO 8601 date-time string (e.g., "2025-10-29T14:30:00").
   *                                If no string is provided, returns an empty string.
   *
   * @returns {string} A formatted string for display in a tooltip.
   *                   Example: "Wednesday 29 October 2025 at 6:46 PM"
   */
  getDateTimeTooltip(timeString?: string): string {
    if (!timeString) return '';

    const messageTime = new Date(timeString);

    // Format date components
    const weekday = messageTime.toLocaleString([], { weekday: 'long' });
    const day = messageTime.getDate();
    const month = messageTime.toLocaleString([], { month: 'long' });
    const year = messageTime.getFullYear();

    // Format time in 12-hour format with concise AM/PM (e.g., "6:46 PM")
    const time = messageTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true }).replace('am', 'AM').replace('pm', 'PM');

    // Return formatted string
    return `${weekday} ${day} ${month} ${year} at ${time}`;
  }

  /**
   * Confirm and execute visibility change
   */
  confirmVisibilityChange(): void {
    if (this.isUpdatingVisibility || !this.groupId || this.pendingVisibilityValue === null) {
      return;
    }

    this.isUpdatingVisibility = true;
    this.cdr.markForCheck();

    this.groupsService.apiGroupsIdVisibilityPut$Json({
      id: this.groupId,
      body: {
        isPublic: this.pendingVisibilityValue
      }
    }).subscribe({
      next: (response) => {
        this.isUpdatingVisibility = false;
        this.showVisibilityConfirmation = false;

        if (response.success && response.data) {
          const visibilityType = this.pendingVisibilityValue ? 'public' : 'private';
          this.toastService.showSuccess(
            `Group visibility changed to ${visibilityType}.`,
            'Visibility Updated'
          );

          // Update local group data
          if (this.group && this.pendingVisibilityValue !== null) {
            this.group.isPublic = this.pendingVisibilityValue;
          }
          this.pendingVisibilityValue = null;
          this.updated.emit(this.group!);
          this.cdr.markForCheck();
        } else {
          this.toastService.showError(
            response.message || 'Failed to update visibility',
            'Update Failed'
          );
          this.pendingVisibilityValue = null;
          this.cdr.markForCheck();
        }
      },
      error: (error) => {
        this.isUpdatingVisibility = false;
        this.showVisibilityConfirmation = false;
        this.pendingVisibilityValue = null;

        const errorMessage = error?.error?.message
          || error?.message
          || 'Failed to update visibility. Please try again.';

        this.toastService.showError(errorMessage, 'Update Failed');
        this.cdr.markForCheck();
      }
    });
  }
}
